
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>aaa: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">yadro.com/course/api/adapters/aaa/auth.go (88.9%)</option>
				
				<option value="file1">yadro.com/course/api/adapters/rest/api.go (0.0%)</option>
				
				<option value="file2">yadro.com/course/api/adapters/rest/middleware/auth.go (0.0%)</option>
				
				<option value="file3">yadro.com/course/api/adapters/rest/middleware/concurrency.go (0.0%)</option>
				
				<option value="file4">yadro.com/course/api/adapters/rest/middleware/rate.go (0.0%)</option>
				
				<option value="file5">yadro.com/course/api/adapters/search/search.go (57.7%)</option>
				
				<option value="file6">yadro.com/course/api/adapters/update/update.go (61.5%)</option>
				
				<option value="file7">yadro.com/course/api/adapters/words/words.go (71.4%)</option>
				
				<option value="file8">yadro.com/course/api/config/config.go (0.0%)</option>
				
				<option value="file9">yadro.com/course/search/adapters/db/storage.go (0.0%)</option>
				
				<option value="file10">yadro.com/course/search/adapters/grpc/server.go (96.3%)</option>
				
				<option value="file11">yadro.com/course/search/adapters/initiator/index_updater.go (0.0%)</option>
				
				<option value="file12">yadro.com/course/search/adapters/words/words.go (0.0%)</option>
				
				<option value="file13">yadro.com/course/search/config/config.go (0.0%)</option>
				
				<option value="file14">yadro.com/course/search/core/models.go (0.0%)</option>
				
				<option value="file15">yadro.com/course/search/core/service.go (0.0%)</option>
				
				<option value="file16">yadro.com/course/update/adapters/db/migrations.go (0.0%)</option>
				
				<option value="file17">yadro.com/course/update/adapters/db/storage.go (0.0%)</option>
				
				<option value="file18">yadro.com/course/update/adapters/grpc/server.go (0.0%)</option>
				
				<option value="file19">yadro.com/course/update/adapters/words/words.go (0.0%)</option>
				
				<option value="file20">yadro.com/course/update/adapters/xkcd/xkcd.go (0.0%)</option>
				
				<option value="file21">yadro.com/course/update/config/config.go (0.0%)</option>
				
				<option value="file22">yadro.com/course/update/core/service.go (0.0%)</option>
				
				<option value="file23">yadro.com/course/words/words/words.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package aaa

import (
        "errors"
        "fmt"
        "os"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

const secretKey = "phoenix"
const adminRole = "superuser"

type Logger interface {
        Error(msg string, keysAndValues ...interface{})
}

type AAA struct {
        users    map[string]string
        tokenTTL time.Duration
        log      Logger
}

func New(tokenTTL time.Duration, log Logger) (AAA, error) <span class="cov7" title="4">{
        const adminUser = "ADMIN_USER"
        const adminPass = "ADMIN_PASSWORD"

        user, exists := os.LookupEnv(adminUser)
        if !exists </span><span class="cov4" title="2">{
                return AAA{}, fmt.Errorf("could not get admin user from enviroment")
        }</span>
        <span class="cov4" title="2">password, exists := os.LookupEnv(adminPass)
        if !exists </span><span class="cov1" title="1">{
                return AAA{}, fmt.Errorf("could not get admin password from enviroment")
        }</span>

        <span class="cov1" title="1">return AAA{
                users:    map[string]string{user: password},
                tokenTTL: tokenTTL,
                log:      log,
        }, nil</span>
}

func (a AAA) Login(name, password, sub string) (string, error) <span class="cov10" title="7">{
        if name == "" </span><span class="cov1" title="1">{
                return "", errors.New("empty user")
        }</span>
        <span class="cov9" title="6">savedPass, ok := a.users[name]
        if !ok </span><span class="cov1" title="1">{
                return "", errors.New("unknown user")
        }</span>
        <span class="cov8" title="5">if savedPass != password </span><span class="cov1" title="1">{
                return "", errors.New("wrong password")
        }</span>

        <span class="cov7" title="4">if sub == "" </span><span class="cov6" title="3">{
                sub = adminRole
        }</span>

        // create token
        <span class="cov7" title="4">token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "sub":  sub,
                "name": name,
                "exp":  jwt.NewNumericDate(time.Now().Add(a.tokenTTL)),
        })

        return token.SignedString([]byte(secretKey))</span>
}

func (a AAA) Verify(tokenString string) error <span class="cov10" title="7">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (any, error) </span><span class="cov6" title="3">{
                return []byte(secretKey), nil
        }</span>)
        <span class="cov10" title="7">if err != nil </span><span class="cov8" title="5">{
                a.log.Error("cannot parse token", "error", err)
                return fmt.Errorf("cannot parse token")
        }</span>
        <span class="cov4" title="2">if !token.Valid </span><span class="cov0" title="0">{
                a.log.Error("token is invalid")
                return errors.New("token is invalid")
        }</span>
        <span class="cov4" title="2">subject, err := token.Claims.GetSubject()
        if err != nil </span><span class="cov0" title="0">{
                a.log.Error("no subject", "error", err)
                return errors.New("incomplete token")
        }</span>
        <span class="cov4" title="2">if subject != adminRole </span><span class="cov1" title="1">{
                a.log.Error("not admin", "subject", subject)
                return errors.New("not authorized")
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package rest

import (
        "encoding/json"
        "errors"
        "log/slog"
        "net/http"

        "strconv"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "yadro.com/course/api/core"
)

func NewPingHandler(log *slog.Logger, pingers map[string]core.Pinger) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{

                m := make(map[string]string, len(pingers))

                for name, pinger := range pingers </span><span class="cov0" title="0">{
                        err := pinger.Ping(r.Context())
                        var res string = "ok"
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("Ping failed", "error", err)
                                res = "unavailable"
                        }</span> else<span class="cov0" title="0"> {
                                log.Debug("Ping success", "service", name)
                        }</span>
                        <span class="cov0" title="0">m[name] = res</span>
                }

                <span class="cov0" title="0">answer := core.PingAnswer{
                        Replies: m,
                }

                w.Header().Set("Content-Type", "application/json")
                enc := json.NewEncoder(w)
                if err := enc.Encode(answer); err != nil </span><span class="cov0" title="0">{
                        log.Error("cannot encode", "error", err)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
        }
}

func NewWordsHandler(log *slog.Logger, server core.Normalizer) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                phrase := r.URL.Query().Get("phrase")
                log.Debug("Got phrase to normalize", "phrase", phrase)

                if phrase == "" </span><span class="cov0" title="0">{
                        log.Error("Phrase is empty")
                        http.Error(w, core.ErrBadArguments.Error(), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">res, err := server.Norm(r.Context(), phrase)

                if err != nil </span><span class="cov0" title="0">{
                        if status.Code(err) == codes.ResourceExhausted </span><span class="cov0" title="0">{
                                log.Error("ResourceExhausted error")
                                http.Error(w, err.Error(), http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov0" title="0">log.Error("Failed to norm", "error", err)
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return</span>
                }

                <span class="cov0" title="0">log.Debug("Norm success", "result", res)

                response := map[string]any{
                        "words": res,
                        "total": len(res),
                }

                w.Header().Set("Content-Type", "application/json")
                enc := json.NewEncoder(w)
                if err := enc.Encode(response); err != nil </span><span class="cov0" title="0">{
                        log.Error("cannot encode", "error", err)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
        }
}

func NewUpdateHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if err := updater.Update(r.Context()); err != nil </span><span class="cov0" title="0">{
                        log.Error("error while update", "error", err)
                        if errors.Is(err, core.ErrAlreadyExists) </span><span class="cov0" title="0">{
                                http.Error(w, err.Error(), http.StatusAccepted)
                                return
                        }</span>
                        <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusInternalServerError)</span>
                }
        }
}

func NewUpdateStatsHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                resp, err := updater.Stats(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Stats failed", "error", err)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                enc := json.NewEncoder(w)
                if err := enc.Encode(resp); err != nil </span><span class="cov0" title="0">{
                        log.Error("Cannot encode", "error", err)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
        }
}

func NewUpdateStatusHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                resp, err := updater.Status(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Status failed", "error", err)
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                enc := json.NewEncoder(w)
                if err := enc.Encode(map[string]core.UpdateStatus{"status": resp}); err != nil </span><span class="cov0" title="0">{
                        log.Error("Cannot encode", "error", err)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>

        }
}

func NewDropHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                err := updater.Drop(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Drop failed", "error", err)
                        w.WriteHeader(http.StatusBadGateway)

                }</span> else<span class="cov0" title="0"> {
                        w.WriteHeader(http.StatusOK)
                }</span>
        }
}

func NewSearchHandler(log *slog.Logger, searcher core.Searcher, words core.Normalizer) http.HandlerFunc <span class="cov0" title="0">{
        type Comics struct {
                ID  int    `json:"id"`
                URL string `json:"url"`
        }

        type ComicsReply struct {
                Comics []Comics `json:"comics"`
                Total  int      `json:"total"`
        }

        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                phrase := r.URL.Query().Get("phrase")
                limit := r.URL.Query().Get("limit")
                log.Debug("Got phrase", "phrase", phrase)
                log.Debug("Got limit", "limit", limit)

                if phrase == "" </span><span class="cov0" title="0">{
                        log.Error("phrase is empty")
                        http.Error(w, core.ErrBadArguments.Error(), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">if limit == "" </span><span class="cov0" title="0">{
                        limit = "10"
                }</span>

                <span class="cov0" title="0">limitInt, err := strconv.Atoi(limit)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to parse limit", "error", err)
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">if limitInt &lt; 0 </span><span class="cov0" title="0">{
                        log.Error("wrong limit", "value", limit)
                        http.Error(w, "bad limit", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">comics, err := searcher.Search(r.Context(), phrase, limitInt)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, core.ErrNotFound) </span><span class="cov0" title="0">{
                                http.Error(w, "no comics found", http.StatusNotFound)
                                return
                        }</span>
                        <span class="cov0" title="0">log.Error("error while seaching", "error", err)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return</span>

                }

                <span class="cov0" title="0">response := ComicsReply{
                        Comics: make([]Comics, 0, len(comics)),
                        Total:  len(comics),
                }

                for _, c := range comics </span><span class="cov0" title="0">{
                        response.Comics = append(response.Comics, Comics{ID: c.ID, URL: c.URL})
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                enc := json.NewEncoder(w)
                if err := enc.Encode(response); err != nil </span><span class="cov0" title="0">{
                        log.Error("cannot encode", "error", err)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
        }
}

func NewSearchIndexHandler(log *slog.Logger, searcher core.Searcher, words core.Normalizer) http.HandlerFunc <span class="cov0" title="0">{
        type Comics struct {
                ID  int    `json:"id"`
                URL string `json:"url"`
        }

        type ComicsReply struct {
                Comics []Comics `json:"comics"`
                Total  int      `json:"total"`
        }

        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                phrase := r.URL.Query().Get("phrase")
                limit := r.URL.Query().Get("limit")
                log.Debug("Got phrase", "phrase", phrase)
                log.Debug("Got limit", "limit", limit)

                if phrase == "" </span><span class="cov0" title="0">{
                        log.Error("phrase is empty")
                        http.Error(w, core.ErrBadArguments.Error(), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">if limit == "" </span><span class="cov0" title="0">{
                        limit = "10"
                }</span>

                <span class="cov0" title="0">limitInt, err := strconv.Atoi(limit)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to parse limit", "error", err)
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">if limitInt &lt; 0 </span><span class="cov0" title="0">{
                        log.Error("wrong limit", "value", limit)
                        http.Error(w, "bad limit", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">comics, err := searcher.SearchIndex(r.Context(), phrase, limitInt)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, core.ErrNotFound) </span><span class="cov0" title="0">{
                                http.Error(w, "no comics found", http.StatusNotFound)
                                return
                        }</span>
                        <span class="cov0" title="0">log.Error("error while seaching", "error", err)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return</span>

                }

                <span class="cov0" title="0">response := ComicsReply{
                        Comics: make([]Comics, 0, len(comics)),
                        Total:  len(comics),
                }

                for _, c := range comics </span><span class="cov0" title="0">{
                        response.Comics = append(response.Comics, Comics{ID: c.ID, URL: c.URL})
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                enc := json.NewEncoder(w)
                if err := enc.Encode(response); err != nil </span><span class="cov0" title="0">{
                        log.Error("cannot encode", "error", err)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
        }
}

type Authenticator interface {
        Login(user, password, sub string) (string, error)
}

type Login struct {
        Name     string `json:"name"`
        Password string `json:"password"`
}

func NewLoginHandler(log *slog.Logger, auth Authenticator) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                var l Login
                if err := json.NewDecoder(r.Body).Decode(&amp;l); err != nil </span><span class="cov0" title="0">{
                        log.Error("could not decode login form", "error", err)
                        http.Error(w, "could not parse login data", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">token, err := auth.Login(l.Name, l.Password, "")
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("could not authenticate", "user", l.Name, "error", err)
                        http.Error(w, core.ErrUserNotFound.Error(), http.StatusUnauthorized)
                }</span>
                <span class="cov0" title="0">if _, err := w.Write([]byte(token)); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to write reply", "error", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "net/http"
        "strings"
)

type TokenVerifier interface {
        Verify(token string) error
}

type Logger interface {
        Error(msg string, keysAndValues ...interface{})
        Debug(msg string, keysAndValues ...interface{})
}

func Auth(log Logger, f http.HandlerFunc, verifier TokenVerifier) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                parts := strings.Fields(r.Header.Get("Authorization"))
                log.Debug("Got token", "token", parts)

                if len(parts) != 2 || parts[0] != "Token" </span><span class="cov0" title="0">{
                        http.Error(w, "bad authorization header", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">if err := verifier.Verify(parts[1]); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "not authorized", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">f.ServeHTTP(w, r)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "net/http"
)

func Concurrency(next http.HandlerFunc, limit int) http.HandlerFunc <span class="cov0" title="0">{
        limiter := make(chan struct{}, limit)
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                select </span>{
                case limiter &lt;- struct{}{}:<span class="cov0" title="0">
                        next.ServeHTTP(w, r)
                        &lt;-limiter</span>
                default:<span class="cov0" title="0">
                        http.Error(w, "try later", http.StatusServiceUnavailable)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import (
        "log/slog"
        "net/http"

        "golang.org/x/time/rate"
)

func Rate(log *slog.Logger, next http.HandlerFunc, rps int) http.HandlerFunc <span class="cov0" title="0">{
        limiter := rate.NewLimiter(rate.Limit(rps), 1)
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if err := limiter.Wait(r.Context()); err != nil </span><span class="cov0" title="0">{
                        log.Error("Rate limit exceeded", "error", err)
                        http.Error(w, "server is going down", http.StatusServiceUnavailable)
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package search

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        "yadro.com/course/api/core"
        searchpb "yadro.com/course/proto/search"
)

type Logger interface {
        Error(msg string, keysAndValues ...interface{})
}

type Client struct {
        log    Logger
        client searchpb.SearchClient
}

func NewClient(address string, log Logger) (*Client, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address,
                grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{log: log, client: searchpb.NewSearchClient(conn)}, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov8" title="1">{
        _, err := c.client.Ping(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (c Client) Search(ctx context.Context, phrase string, limit int) ([]core.Comics, error) <span class="cov8" title="1">{
        reply, err := c.client.Search(ctx, &amp;searchpb.SearchRequest{
                Phrase: phrase, Limit: int64(limit),
        })
        if err != nil </span><span class="cov0" title="0">{
                if status.Code(err) == codes.NotFound </span><span class="cov0" title="0">{
                        return nil, core.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">comics := make([]core.Comics, 0, len(reply.Comics))
        for _, c := range reply.Comics </span><span class="cov8" title="1">{
                comics = append(comics, core.Comics{ID: int(c.Id), URL: c.Url})
        }</span>
        <span class="cov8" title="1">return comics, nil</span>

}

func (c Client) SearchIndex(ctx context.Context, phrase string, limit int) ([]core.Comics, error) <span class="cov8" title="1">{
        reply, err := c.client.SearchIndex(ctx, &amp;searchpb.SearchRequest{
                Phrase: phrase, Limit: int64(limit),
        })
        if err != nil </span><span class="cov0" title="0">{
                if status.Code(err) == codes.NotFound </span><span class="cov0" title="0">{
                        return nil, core.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">comics := make([]core.Comics, 0, len(reply.Comics))
        for _, c := range reply.Comics </span><span class="cov8" title="1">{
                comics = append(comics, core.Comics{ID: int(c.Id), URL: c.Url})
        }</span>
        <span class="cov8" title="1">return comics, nil</span>

}
</pre>
		
		<pre class="file" id="file6" style="display: none">package update

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        "yadro.com/course/api/core"
        updatepb "yadro.com/course/proto/update"
)

type Logger interface {
        Error(msg string, keysAndValues ...interface{})
}

type Client struct {
        log    Logger
        client updatepb.UpdateClient
}

func NewClient(address string, log Logger) (*Client, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{
                client: updatepb.NewUpdateClient(conn),
                log:    log,
        }, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov8" title="1">{
        _, err := c.client.Ping(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (c Client) Status(ctx context.Context) (core.UpdateStatus, error) <span class="cov8" title="1">{
        resp, err := c.client.Status(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return core.StatusUpdateUnknown, err
        }</span>

        <span class="cov8" title="1">if resp.Status == updatepb.Status_STATUS_RUNNING </span><span class="cov0" title="0">{
                return core.StatusUpdateRunning, nil
        }</span> else<span class="cov8" title="1"> {
                return core.StatusUpdateIdle, nil
        }</span>
}

func (c Client) Stats(ctx context.Context) (core.UpdateStats, error) <span class="cov8" title="1">{
        resp, err := c.client.Stats(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return core.UpdateStats{}, err
        }</span>
        <span class="cov8" title="1">return core.UpdateStats{
                WordsTotal:    int(resp.WordsTotal),
                WordsUnique:   int(resp.WordsUnique),
                ComicsTotal:   int(resp.ComicsTotal),
                ComicsFetched: int(resp.ComicsFetched),
        }, nil</span>

}

func (c Client) Update(ctx context.Context) error <span class="cov8" title="1">{
        _, err := c.client.Update(ctx, &amp;emptypb.Empty{})
        if status.Code(err) == codes.AlreadyExists </span><span class="cov0" title="0">{
                return core.ErrAlreadyExists
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c Client) Drop(ctx context.Context) error <span class="cov8" title="1">{
        _, err := c.client.Drop(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package words

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/protobuf/types/known/emptypb"
        wordspb "yadro.com/course/proto/words"
)

type Logger interface {
        Error(msg string, keysAndValues ...interface{})
        Info(msg string, keysAndValues ...interface{})
}

type Client struct {
        log    Logger
        client wordspb.WordsClient
}

func NewClient(address string, log Logger) (*Client, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address,
                grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{log: log, client: wordspb.NewWordsClient(conn)}, nil</span>
}

func (c Client) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov10" title="2">{
        r, err := c.client.Norm(ctx, &amp;wordspb.WordsRequest{Phrase: phrase})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("Could not norm phrase", "error", err)
                return nil, err
        }</span>
        <span class="cov1" title="1">c.log.Info("Norm success", "return", r.Words)
        return r.Words, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov10" title="2">{
        _, err := c.client.Ping(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "log"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type HTTPConfig struct {
        Address string        `yaml:"address" env:"API_ADDRESS" env-default:"localhost:80"`
        Timeout time.Duration `yaml:"timeout" env:"API_TIMEOUT" env-default:"5s"`
}

type Config struct {
        LogLevel          string        `yaml:"log_level" env:"LOG_LEVEL" env-default:"DEBUG"`
        HTTPConfig        HTTPConfig    `yaml:"api_server"`
        WordsAddress      string        `yaml:"words_address" env:"WORDS_ADDRESS" env-default:"words:81"`
        UpdateAddress     string        `yaml:"update_address" env:"UPDATE_ADDRESS" env-default:"update:82"`
        SearchAddress     string        `yaml:"search_address" env:"SEARCH_ADDRESS" env-default:"search:83"`
        SearchConcurrency int           `yaml:"search_concurrency" env:"SEARCH_CONCURRENCY" env-default:"1"`
        SearchRate        int           `yaml:"search_rate" env:"SEARCH_RATE" env-default:"1"`
        TokenTTL          time.Duration `yaml:"token_ttl" env:"TOKEN_TTL" env-default:"24h"`
}

func MustLoad(configPath string) Config <span class="cov0" title="0">{
        var cfg Config
        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("cannot read config %q: %s", configPath, err)
        }</span>
        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package db

import (
        "context"
        "log/slog"

        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
        "github.com/lib/pq"
        "yadro.com/course/search/core"
)

type DB struct {
        log  *slog.Logger
        conn *sqlx.DB
}

func New(log *slog.Logger, address string) (*DB, error) <span class="cov0" title="0">{

        db, err := sqlx.Connect("pgx", address)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("connection problem", "address", address, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;DB{
                log:  log,
                conn: db,
        }, nil</span>
}

func (db *DB) Search(ctx context.Context, keyword string) ([]int, error) <span class="cov0" title="0">{
        var IDs []int
        err := db.conn.SelectContext(
                ctx, &amp;IDs,
                "SELECT id FROM comics WHERE $1 = ANY(words)",
                keyword,
        )

        return IDs, err
}</span>

type Comics struct {
        ID       int            `db:"id"`
        URL      string         `db:"url"`
        Keywords pq.StringArray `db:"words"`
}

func (db *DB) Get(ctx context.Context, id int) (core.Comics, error) <span class="cov0" title="0">{
        var comics Comics
        err := db.conn.GetContext(
                ctx, &amp;comics,
                "SELECT id, url, words FROM comics WHERE id = $1",
                id,
        )

        return core.Comics{ID: comics.ID, URL: comics.URL, Keywords: comics.Keywords}, err
}</span>

func (db *DB) LastID(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var ID int
        err := db.conn.GetContext(
                ctx, &amp;ID,
                "SELECT COALESCE(max(id), 0) FROM comics",
        )

        return ID, err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package grpc

import (
        "context"
        "errors"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        searchpb "yadro.com/course/proto/search"
        "yadro.com/course/search/core"
)

const defaultLimit = 10

func NewServer(service core.Searcher) *Server <span class="cov0" title="0">{
        return &amp;Server{service: service}
}</span>

type Server struct {
        searchpb.UnimplementedSearchServer
        service core.Searcher
}

func (s *Server) Ping(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov5" title="2">{
        err := s.service.Ping(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return nil, nil</span>
}

func (s *Server) Search(
        ctx context.Context, req *searchpb.SearchRequest,
) (*searchpb.SearchReply, error) <span class="cov10" title="4">{
        if req.Limit == 0 </span><span class="cov1" title="1">{
                req.Limit = defaultLimit
        }</span>
        <span class="cov10" title="4">results, err := s.service.Search(ctx, req.Phrase, int(req.Limit))
        if err != nil </span><span class="cov5" title="2">{
                if errors.Is(err, core.ErrNotFound) </span><span class="cov1" title="1">{
                        return nil, status.Error(codes.NotFound, "nothing found")
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }
        <span class="cov5" title="2">comics := make([]*searchpb.Comics, 0, len(results))
        for _, c := range results </span><span class="cov10" title="4">{
                comics = append(comics, &amp;searchpb.Comics{
                        Id:  int64(c.ID),
                        Url: c.URL,
                })
        }</span>
        <span class="cov5" title="2">return &amp;searchpb.SearchReply{Comics: comics}, nil</span>
}

func (s *Server) SearchIndex(
        ctx context.Context, req *searchpb.SearchRequest,
) (*searchpb.SearchReply, error) <span class="cov10" title="4">{
        if req.Limit == 0 </span><span class="cov1" title="1">{
                req.Limit = defaultLimit
        }</span>
        <span class="cov10" title="4">results, err := s.service.SearchIndex(ctx, req.Phrase, int(req.Limit))
        if err != nil </span><span class="cov5" title="2">{
                if errors.Is(err, core.ErrNotFound) </span><span class="cov1" title="1">{
                        return nil, status.Error(codes.NotFound, "nothing found")
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }
        <span class="cov5" title="2">comics := make([]*searchpb.Comics, 0, len(results))
        for _, c := range results </span><span class="cov10" title="4">{
                comics = append(comics, &amp;searchpb.Comics{
                        Id:  int64(c.ID),
                        Url: c.URL,
                })
        }</span>
        <span class="cov5" title="2">return &amp;searchpb.SearchReply{Comics: comics}, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package initiator

import (
        "context"
        "log/slog"
        "time"

        "yadro.com/course/search/core"
)

func RunIndexUpdate(ctx context.Context, searcher core.Searcher, period time.Duration, log *slog.Logger) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                // update on start
                if err := searcher.BuildIndex(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to build index on start", "error", err)
                }</span>
                <span class="cov0" title="0">ticker := time.NewTicker(period)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                log.Error("quit updater")</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                log.Info("run index update")
                                if err := searcher.BuildIndex(ctx); err != nil </span><span class="cov0" title="0">{
                                        log.Error("build index failed", "error", err)
                                }</span>
                        }
                }
        }()
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package words

import (
        "context"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/status"
        wordspb "yadro.com/course/proto/words"
        "yadro.com/course/search/core"
)

type Client struct {
        log    *slog.Logger
        client wordspb.WordsClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{
                client: wordspb.NewWordsClient(conn),
                log:    log,
        }, nil</span>
}

func (c Client) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov0" title="0">{
        reply, err := c.client.Norm(ctx, &amp;wordspb.WordsRequest{Phrase: phrase})
        if err != nil </span><span class="cov0" title="0">{
                if status.Code(err) == codes.ResourceExhausted </span><span class="cov0" title="0">{
                        return nil, core.ErrBadArguments
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return reply.GetWords(), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "log"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type Config struct {
        LogLevel     string        `yaml:"log_level" env:"LOG_LEVEL" env-default:"DEBUG"`
        IndexTTL     time.Duration `yaml:"index_ttl" env:"INDEX_TTL" env-default:"1h"`
        Address      string        `yaml:"search_address" env:"SEARCH_ADDRESS" env-default:"localhost:80"`
        DBAddress    string        `yaml:"db_address" env:"DB_ADDRESS" env-default:"localhost:82"`
        WordsAddress string        `yaml:"words_address" env:"WORDS_ADDRESS" env-default:"localhost:81"`
}

func MustLoad(configPath string) Config <span class="cov0" title="0">{
        var cfg Config
        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("cannot read config %q: %s", configPath, err)
        }</span>
        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package core

import (
        "slices"
        "sync"
)

type Comics struct {
        ID       int      `db:"id"`
        URL      string   `db:"url"`
        Keywords []string `db:"words"`
        Score    int
}

type Index struct {
        index map[string][]int
        lock  sync.RWMutex
}

func NewIndex() *Index <span class="cov0" title="0">{
        return &amp;Index{
                index: make(map[string][]int),
        }
}</span>

func (i *Index) Clear() <span class="cov0" title="0">{
        i.lock.Lock()
        i.index = make(map[string][]int)
        i.lock.Unlock()
}</span>

func (i *Index) Put(id int, keywords []string) <span class="cov0" title="0">{
        i.lock.Lock()
        for _, keyword := range keywords </span><span class="cov0" title="0">{
                i.index[keyword] = append(i.index[keyword], id)
        }</span>
        <span class="cov0" title="0">i.lock.Unlock()</span>
}

func (i *Index) Get(keyword string) []int <span class="cov0" title="0">{
        i.lock.RLock()
        defer i.lock.RUnlock()
        return slices.Clone(i.index[keyword])
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package core

import (
        "cmp"
        "context"
        "errors"
        "fmt"
        "log/slog"
        "maps"
        "slices"
)

type Service struct {
        log   *slog.Logger
        db    DB
        words Words
        index *Index
}

func NewService(
        log *slog.Logger, db DB, words Words) (*Service, error) <span class="cov0" title="0">{
        return &amp;Service{
                log:   log,
                db:    db,
                words: words,
                index: NewIndex(),
        }, nil
}</span>

func (s *Service) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *Service) Search(ctx context.Context, phrase string, limit int) ([]Comics, error) <span class="cov0" title="0">{
        normed, err := s.words.Norm(ctx, phrase)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to find keywords", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">s.log.Debug("normalized query", "keywords", normed)

        scores := map[int]int{}
        for _, keyword := range normed </span><span class="cov0" title="0">{
                IDs, err := s.db.Search(ctx, keyword)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Error("failed to search keyword in DB", "error", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">for _, ID := range IDs </span><span class="cov0" title="0">{
                        scores[ID]++
                }</span>
        }

        <span class="cov0" title="0">return s.fetch(ctx, scores, limit)</span>
}

func (s *Service) SearchIndex(ctx context.Context, phrase string, limit int) ([]Comics, error) <span class="cov0" title="0">{
        keywords, err := s.words.Norm(ctx, phrase)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to find keywords", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">s.log.Debug("normalized query", "keywords", keywords)

        // comics ID -&gt; number of findings
        scores := map[int]int{}
        for _, keyword := range keywords </span><span class="cov0" title="0">{
                for _, ID := range s.index.Get(keyword) </span><span class="cov0" title="0">{
                        scores[ID]++
                }</span>
        }

        <span class="cov0" title="0">return s.fetch(ctx, scores, limit)</span>

}

func (s *Service) fetch(ctx context.Context, scores map[int]int, limit int) ([]Comics, error) <span class="cov0" title="0">{
        s.log.Debug("relevant comics", "count", len(scores))

        // sort by number of findings
        sorted := slices.SortedFunc(maps.Keys(scores), func(a, b int) int </span><span class="cov0" title="0">{
                return cmp.Compare(scores[b], scores[a]) // desc
        }</span>)

        // limit results
        <span class="cov0" title="0">if len(sorted) &lt; limit </span><span class="cov0" title="0">{
                limit = len(sorted)
        }</span>
        <span class="cov0" title="0">sorted = sorted[:limit]

        // fetch comics
        result := make([]Comics, 0, len(sorted))
        for _, ID := range sorted </span><span class="cov0" title="0">{
                comics, err := s.db.Get(ctx, ID)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Error("failed to fetch comics", "id", ID, "error", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">comics.Score = scores[ID]
                result = append(result, comics)</span>
        }
        <span class="cov0" title="0">s.log.Debug("returning comics", "count", len(result))

        return result, nil</span>
}

func (s *Service) BuildIndex(ctx context.Context) error <span class="cov0" title="0">{
        s.log.Debug("building index")
        s.index.Clear()
        s.log.Debug("cleared current index")
        lastID, err := s.db.LastID(ctx)
        s.log.Debug(fmt.Sprintf("got lastID: %d", lastID))

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var comicsCount int
        for ID := 1; ID &lt;= lastID; ID++ </span><span class="cov0" title="0">{
                comics, err := s.db.Get(ctx, ID)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, ErrNotFound) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">s.log.Error("failed to fetch comics", "id", ID, "error", err)
                        return err</span>
                }
                <span class="cov0" title="0">s.index.Put(ID, comics.Keywords)
                comicsCount++</span>
        }

        <span class="cov0" title="0">s.log.Debug("rebuilt index", "comics count", comicsCount)
        return nil</span>

}
</pre>
		
		<pre class="file" id="file16" style="display: none">package db

import (
        "embed"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/pgx"
        "github.com/golang-migrate/migrate/v4/source/iofs"
)

//go:embed migrations/*.sql
var migrationFiles embed.FS

func (db *DB) Migrate() error <span class="cov0" title="0">{
        db.log.Debug("running migration")
        files, err := iofs.New(migrationFiles, "migrations") // get migrations from
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">driver, err := pgx.WithInstance(db.conn.DB, &amp;pgx.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">m, err := migrate.NewWithInstance("iofs", files, "pgx", driver)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = m.Up()

        if err != nil </span><span class="cov0" title="0">{
                if err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                        db.log.Error("migration failed", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">db.log.Debug("migration did not change anything")</span>
        }

        <span class="cov0" title="0">db.log.Debug("migration finished")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package db

import (
        "context"
        "database/sql"
        "errors"
        "log/slog"

        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
        "yadro.com/course/update/core"
)

type DB struct {
        log  *slog.Logger
        conn *sqlx.DB
}

func New(log *slog.Logger, address string) (*DB, error) <span class="cov0" title="0">{

        db, err := sqlx.Connect("pgx", address)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("connection problem", "address", address, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;DB{
                log:  log,
                conn: db,
        }, nil</span>
}

func (db *DB) Add(ctx context.Context, comics core.Comics) error <span class="cov0" title="0">{
        _, err := db.conn.ExecContext(
                ctx,
                "INSERT INTO comics (id, url, words) VALUES($1, $2, $3)",
                comics.ID, comics.URL, comics.Words,
        )

        return err

}</span>

func (db *DB) Stats(ctx context.Context) (core.DBStats, error) <span class="cov0" title="0">{
        var stats core.DBStats
        err := db.conn.GetContext(
                ctx, &amp;stats.ComicsFetched,
                "SELECT COUNT(*) FROM comics")
        if err != nil </span><span class="cov0" title="0">{
                return core.DBStats{}, err
        }</span>
        <span class="cov0" title="0">err = db.conn.GetContext(
                ctx, &amp;stats.WordsTotal,
                "SELECT coalesce(SUM(array_length(words,1)), 0) FROM comics",
        )
        if err != nil </span><span class="cov0" title="0">{
                return core.DBStats{}, err
        }</span>
        <span class="cov0" title="0">err = db.conn.GetContext(
                ctx, &amp;stats.WordsUnique,
                "SELECT count(*) FROM (SELECT distinct(unnest(words)) FROM comics)",
        )
        if err != nil </span><span class="cov0" title="0">{
                return core.DBStats{}, err
        }</span>

        <span class="cov0" title="0">return stats, nil</span>

}

func (db *DB) IDs(ctx context.Context) ([]int, error) <span class="cov0" title="0">{
        var IDs []int
        err := db.conn.SelectContext(
                ctx, &amp;IDs,
                "SELECT id FROM comics")
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return IDs, nil</span>

}

func (db *DB) Drop(ctx context.Context) error <span class="cov0" title="0">{
        _, err := db.conn.ExecContext(ctx, "TRUNCATE comics")
        return err
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package grpc

import (
        "context"
        "errors"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        updatepb "yadro.com/course/proto/update"
        "yadro.com/course/update/core"
)

func NewServer(service core.Updater) *Server <span class="cov0" title="0">{
        return &amp;Server{service: service}
}</span>

type Server struct {
        updatepb.UnimplementedUpdateServer
        service core.Updater
}

func (s *Server) Ping(_ context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (s *Server) Status(ctx context.Context, _ *emptypb.Empty) (*updatepb.StatusReply, error) <span class="cov0" title="0">{
        res := s.service.Status(ctx)

        switch res </span>{
        case core.StatusIdle:<span class="cov0" title="0">
                return &amp;updatepb.StatusReply{Status: updatepb.Status_STATUS_IDLE}, nil</span>
        case core.StatusRunning:<span class="cov0" title="0">
                return &amp;updatepb.StatusReply{Status: updatepb.Status_STATUS_RUNNING}, nil</span>
        }
        <span class="cov0" title="0">return nil, status.Error(codes.Internal, "Unknown status from service")</span>

}

func (s *Server) Update(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if err := s.service.Update(ctx); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, core.ErrAlreadyExists) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.AlreadyExists, "Update is running")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

func (s *Server) Stats(ctx context.Context, _ *emptypb.Empty) (*updatepb.StatsReply, error) <span class="cov0" title="0">{
        res, err := s.service.Stats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;updatepb.StatsReply{
                WordsTotal:    int64(res.WordsTotal),
                WordsUnique:   int64(res.WordsUnique),
                ComicsFetched: int64(res.ComicsFetched),
                ComicsTotal:   int64(res.ComicsTotal),
        }, nil</span>
}

func (s *Server) Drop(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if err := s.service.Drop(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package words

import (
        "context"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        wordspb "yadro.com/course/proto/words"
)

type Client struct {
        log    *slog.Logger
        client wordspb.WordsClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{
                client: wordspb.NewWordsClient(conn),
                log:    log,
        }, nil</span>
}

func (c Client) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov0" title="0">{
        r, err := c.client.Norm(ctx, &amp;wordspb.WordsRequest{Phrase: phrase})
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error("Could not norm phrase", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">c.log.Info("Norm success", "return", r.Words)
        return r.Words, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov0" title="0">{
        _, err := c.client.Ping(ctx, nil)
        return err
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package xkcd

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "strings"
        "time"

        "yadro.com/course/update/core"
)

type Client struct {
        log    *slog.Logger
        client http.Client
        url    string
}

const uriPath = "/info.0.json"

func NewClient(url string, timeout time.Duration, log *slog.Logger) (*Client, error) <span class="cov0" title="0">{
        if url == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty base url specified")
        }</span>
        <span class="cov0" title="0">return &amp;Client{
                client: http.Client{Timeout: timeout},
                log:    log,
                url:    url,
        }, nil</span>
}

func fetchComic(url string) (core.XKCDInfo, error) <span class="cov0" title="0">{
        resp, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return core.XKCDInfo{}, fmt.Errorf("failed to make a comic request: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return core.XKCDInfo{}, core.ErrNotFound
        }</span>
        <span class="cov0" title="0">info := struct {
                ID         int    `json:"num"`
                URL        string `json:"img"`
                Title      string `json:"title"`
                SafeTitle  string `json:"safe_title"`
                Transcript string `json:"transcript"`
                Alt        string `json:"alt"`
        }{}

        if err := json.NewDecoder(resp.Body).Decode(&amp;info); err != nil </span><span class="cov0" title="0">{
                return core.XKCDInfo{}, err
        }</span>

        <span class="cov0" title="0">return core.XKCDInfo{
                ID:    info.ID,
                URL:   info.URL,
                Title: info.Title,
                Description: strings.Join([]string{
                        info.Title, info.SafeTitle, info.Transcript, info.Alt},
                        " "),
        }, nil</span>
}

func (c Client) Get(ctx context.Context, id int) (core.XKCDInfo, error) <span class="cov0" title="0">{
        resp, err := fetchComic(c.url + fmt.Sprintf("/%d/%s", id, uriPath))
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error("Could not fetch comic", "error", err)
                return resp, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

func (c Client) LastID(ctx context.Context) (int, error) <span class="cov0" title="0">{
        resp, err := fetchComic(c.url + fmt.Sprintf("/%s", uriPath))
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error("Could not fetch comic", "error", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return resp.ID, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package config

import (
        "log"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type XKCD struct {
        URL         string        `yaml:"url" env:"XKCD_URL" env-default:"xkcd.com"`
        Concurrency int           `yaml:"concurrency" env:"XKCD_CONCURRENCY" env-default:"1"`
        Timeout     time.Duration `yaml:"timeout" env:"XKCD_TIMEOUT" env-default:"10s"`
        CheckPeriod time.Duration `yaml:"check_period" env:"XKCD_CHECK_PERIOD" env-default:"1h"`
}

type Config struct {
        LogLevel     string `yaml:"log_level" env:"LOG_LEVEL" env-default:"DEBUG"`
        Address      string `yaml:"update_address" env:"UPDATE_ADDRESS" env-default:"localhost:80"`
        XKCD         XKCD   `yaml:"xkcd"`
        DBAddress    string `yaml:"db_address" env:"DB_ADDRESS" env-default:"localhost:82"`
        WordsAddress string `yaml:"words_address" env:"WORDS_ADDRESS" env-default:"localhost:81"`
}

func MustLoad(configPath string) Config <span class="cov0" title="0">{
        var cfg Config
        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("cannot read config %q: %s", configPath, err)
        }</span>
        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package core

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
        "sync/atomic"
        "time"
)

type Service struct {
        log         *slog.Logger
        db          DB
        xkcd        XKCD
        words       Words
        concurrency int
        inProgress  atomic.Bool
        lock        sync.Mutex
}

func NewService(
        log *slog.Logger, db DB, xkcd XKCD, words Words, concurrency int,
) (*Service, error) <span class="cov0" title="0">{
        if concurrency &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wrong concurrency specified: %d", concurrency)
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                log:         log,
                db:          db,
                xkcd:        xkcd,
                words:       words,
                concurrency: concurrency,
        }, nil</span>
}

func (s *Service) Update(ctx context.Context) (err error) <span class="cov0" title="0">{
        if ok := s.lock.TryLock(); !ok </span><span class="cov0" title="0">{
                s.log.Error("Service already runs update")
                return ErrAlreadyExists
        }</span>
        <span class="cov0" title="0">defer s.lock.Unlock()

        s.inProgress.Store(true)
        defer s.inProgress.Store(false)

        s.log.Info("Update started")
        defer func(start time.Time) </span><span class="cov0" title="0">{
                s.log.Info("Update finished", "duration", time.Since(start), "error", err)
        }</span>(time.Now())

        <span class="cov0" title="0">IDs, err := s.db.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("Failed to get existing IDs in DB", "error", err)
                return fmt.Errorf("failed to get existing IDs in DB: %v", err)
        }</span>

        <span class="cov0" title="0">s.log.Debug("Existing comics in DB", "count", len(IDs))
        exists := make(map[int]bool, len(IDs))
        for _, id := range IDs </span><span class="cov0" title="0">{
                exists[id] = true
        }</span>

        // get last comics ID
        <span class="cov0" title="0">latestComicID, err := s.xkcd.LastID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("Failed to get latest comic", "error", err)
                return fmt.Errorf("failed to get last ID in XKCD: %v", err)
        }</span>

        <span class="cov0" title="0">s.log.Debug("Last comics ID in XKCD", "id", latestComicID)

        generator := generateIDs(ctx, 1, latestComicID, exists)
        fetchers := s.getComics(ctx, generator)

        var errorsFound bool
        var added int
        for info := range fetchers </span><span class="cov0" title="0">{
                words, err := s.words.Norm(ctx, info.Description+" "+info.Title)
                if err != nil </span><span class="cov0" title="0">{
                        errorsFound = true
                        s.log.Error("Failed to normalize", "id", info.ID, "error", err)
                        continue</span>
                }
                <span class="cov0" title="0">err = s.db.Add(ctx, Comics{
                        ID:    info.ID,
                        URL:   info.URL,
                        Words: words,
                })
                if err != nil </span><span class="cov0" title="0">{
                        errorsFound = true
                        s.log.Error("Failed to save comics", "id", info.ID, "error", err)
                        continue</span>
                }
                <span class="cov0" title="0">added++</span>
        }
        <span class="cov0" title="0">s.log.Debug("Added new comics", "count", added)

        if errorsFound </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to fetch/store some comics")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func generateIDs(ctx context.Context, first, last int, exists map[int]bool) &lt;-chan int <span class="cov0" title="0">{
        ch := make(chan int)
        go func() </span><span class="cov0" title="0">{
                defer close(ch)
                for i := first; i &lt;= last; i++ </span><span class="cov0" title="0">{
                        if exists[i] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                ch &lt;- i</span>
                        }
                }
        }()
        <span class="cov0" title="0">return ch</span>
}

func (s *Service) getComics(ctx context.Context, in &lt;-chan int) &lt;-chan XKCDInfo <span class="cov0" title="0">{
        out := make(chan XKCDInfo)
        var wg sync.WaitGroup
        wg.Add(s.concurrency)

        for i := range s.concurrency </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        s.log.Debug("Fetcher up", "id", i)
                        defer s.log.Debug("Fetcher down", "id", i)
                        defer wg.Done()
                        for id := range in </span><span class="cov0" title="0">{
                                if id == 404 </span><span class="cov0" title="0">{
                                        // special case
                                        out &lt;- XKCDInfo{ID: id, Title: "404", Description: "Not found"}
                                        continue</span>
                                }
                                <span class="cov0" title="0">info, err := s.xkcd.Get(ctx, id)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.log.Error("Failed to get comics", "id", id, "error", err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">s.log.Debug("Fetched", "id", id)
                                out &lt;- info</span>
                        }
                }()
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(out)
        }</span>()
        <span class="cov0" title="0">return out</span>
}

func (s *Service) Stats(ctx context.Context) (ServiceStats, error) <span class="cov0" title="0">{
        dbStats, err := s.db.Stats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to get stats", "error", err)
                return ServiceStats{}, err
        }</span>
        <span class="cov0" title="0">lastID, err := s.xkcd.LastID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to get last comics ID", "error", err)
                return ServiceStats{}, err
        }</span>
        <span class="cov0" title="0">return ServiceStats{
                DBStats:     dbStats,
                ComicsTotal: lastID,
        }, nil</span>
}

func (s *Service) Status(ctx context.Context) ServiceStatus <span class="cov0" title="0">{
        if s.inProgress.Load() </span><span class="cov0" title="0">{
                return StatusRunning
        }</span>
        <span class="cov0" title="0">return StatusIdle</span>

}

func (s *Service) Drop(ctx context.Context) error <span class="cov0" title="0">{
        err := s.db.Drop(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to drop db entries", "error", err)
        }</span>
        <span class="cov0" title="0">s.log.Debug("DB dropped")
        return err</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package words

import (
        "maps"
        "slices"
        "strings"
        "unicode"

        snowball "github.com/kljensen/snowball"
        "github.com/kljensen/snowball/english"
)

func cleanText(c rune) bool <span class="cov0" title="0">{
        return !(unicode.IsLetter(c) || unicode.IsNumber(c))
}</span>

func Norm(phrase string) []string <span class="cov0" title="0">{
        phrases := strings.FieldsFunc(phrase, cleanText)
        stemmed := make(map[string]bool, len(phrases))
        for _, word := range phrases </span><span class="cov0" title="0">{

                // empty check
                if word == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">word = strings.ToLower(word)

                if english.IsStopWord(word) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // stemming
                <span class="cov0" title="0">stem, err := snowball.Stem(word, "english", true)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // empty after stemming check
                <span class="cov0" title="0">if stem == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">stemmed[stem] = true</span>
        }
        <span class="cov0" title="0">return slices.Collect(maps.Keys(stemmed))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
