# Сервис для работы с комиксами XKCD

Структура проекта в виде популярной архитектуры Ports & Adapters,
она же гексагональная архитектура. Такая архитектура предполагает принцип инверсии зависимостей.

Сервис собирается и запускается через предоставленный compose файл,
а также проходит интеграционные тесты через запуск специального тест контейнера.

## Words

Микросервис, обслуживающий клиентов по gRPC протоколу. 

Mикросервис работает в соответсвии с proto-структурой.
Сервис принимает на вход строку (на английском) и возвращает назад нормализованный вид
в виде слайса слов. То есть при посылке "follower brings bunch of questions" сервер отдает
["follow", "bring", "bunch", "question"] - слова в слайсе в любом порядке.

Микросервис отсеивает часто употребляемые слова типа of/a/the/, местоимения
и глагольные частицы (will).

Для нормализации используется библиотека
[snowball](github.com/kljensen/snowball)

Сервис возвращает gRPC ошибку при получении сообщения больше 4 KiB - 
[ResourceExhausted](https://pkg.go.dev/google.golang.org/grpc/codes#pkg-constants).

## API Gateway

REST-шлюз для поисковых микросервисов. 

Mикросервис API gateway работает по REST протоколу в соответсвии со
схемой:

1. По запросу "GET /ping" сервис отдает ответ о состоянии поисковых сервисов.
При таком запросе gateway запрашивает по gRPC состояния других микросервисов.
Ответ приходит в виде JSON:
```
{
    "replies": [
        "words": "ok",
        "update": "ok",
        "search": "ok",
    ]
}
```

2. По запросу "GET /api/words?phrase="follow, followers" cервис принимает на вход строку
(на английском) и возвращает назад нормализованный вид в виде структуры со слайсом слов.

То есть при посылке "follower brings bunch of questions" сервер отдает
["follow", "bring", "bunch", "question"] - слова в слайсе в любом порядке. Формат ответа - JSON:
```
{
    "words": ["follow", "bring", "bunch", "question"],
    "total": 4
}
```
При успешном запросе отдается HTTP статус OK, при отсутствии или пустом phrase - Bad Request.
Также реализована трансляция gRPC кода при получении сообщения больше 4 KiB -
ResourceExhausted в Bad Request.


## XKCD

Микросервис, который скачивает информацию о комиксах с сайта https://xkcd.com
и сохраняет ее в базе данных (Postgres) в удобном для поиска формате.

Mикросервис update при запуске создает нужные таблицы в DB, если таковые не созданы,
отвечает по gRPC протоколу в API gateway. 

1. По запросу "GET /api/ping" gateway отдает ответ о состоянии поисковых сервисов.
При таком запросе gateway запрашивает по gRPC состояния других микросервисов.
Ответ в виде JSON:
```
{
    "replies": [
        "words": "ok",
        "update": "ok"
    ]
}
```

2. По запросу "GET /api/db/stats gateway отдает статистику из базы данных и
сайта XKCD ответом JSON:
```
{
    "words_total": 0,
    "words_unique": 0,
    "comics_fetched": 0,
    "comics_total": 3043
}
```

3. По запросу "POST /api/db/update"  синхроно запускается в сервисе update идемпотентное
обновление базы комиксов (скачивает только те, которых не хватает). Комиксы хранятся в XKCD
по адресам следующего вида - https://xkcd.com/777/info.0.json , где 777 - номер комикса. В базе 
сохраняется информация о URL картинки, ID комикса и ключевые слова, которые
предварительно отфильтровываются и нормализуются в сервисе words, для каждого обработанного
комикса.

4. Если запустить обновление базы в update одновременно через два cURL (Postman, etc), то одно
из них продолжиться, а другой запрос возвратит статус HTTP Accepted.

5. При отсутствии процесса обновления на запрос "GET /api/db/status" возвращается JSON вида
```
{
    "status": "idle"
}
```
Если обновление запущено, возвращается статус "running".

## Search

Микросервис, который ищет по базе данных нужные комиксы.

Mикросервис search отвечает по gRPC протоколу в API gateway. 

1. По запросу "GET /api/ping" gateway отдает ответ о состоянии поисковых сервисов.
При таком запросе gateway запрашивает по gRPC состояния других микросервисов.
Ответ в виде JSON:
```
{
    "replies": [
        "words": "ok",
        "update": "ok"
        "search": "ok"
    ]
}
```

2. По запросу "GET /api/search?limit=2&phrase=linux,forever" gateway отдает
найденные сервисом search комиксы ответом JSON:
```
{
  "comics": [
    {
      "id": 196,
      "url": "https://imgs.xkcd.com/comics/command_line_fu.png"
    },
    {
      "id": 619,
      "url": "https://imgs.xkcd.com/comics/supported_features.png"
    }
  ],
  "total": 2
}
```

Указан пример ответа. С gateway отправляется отформатированный JSON. Для пустого phrase, неправильного limit возвращается bad request.
limit по умолчанию принимает значение 10.

search сервис принимает фразу пользователя, нормализует ее, ищет и сортирует
релевантные комиксы. 

Есть возможность поиска по индексу. 
Индекс представляет собой отображение ключевых слов в список идетификаторов комиксов,
в которых эти слова найдены. 

3. По запросу "GET /api/isearch?limit=2&phrase=linux,forever" gateway отдает
найденные сервисом search комиксы ответом JSON:
```
{
  "comics": [
    {
      "id": 196,
      "url": "https://imgs.xkcd.com/comics/command_line_fu.png"
    },
    {
      "id": 619,
      "url": "https://imgs.xkcd.com/comics/supported_features.png"
    }
  ],
  "total": 2
}
```

Построение индекса инициируется с помощью "инициатора". Это активный тип адаптера, который
адаптирует, в данном примере, "тики" таймера в вызов метода построения индекса в бизнес-логике.
Инициатор конфигурируется через config.yaml или переменную среды. Запуск инициатора
сопровождается незамедлительным вызовом построения индекса, без ожидания таймера, затем индекс
обновляется по таймеру.

# AAA

Нагрузку на сервис ограничена с помощью rate и concurrency limiters.

Для endpoint-а /api/search, который ходит напрямую в базу данных, добавлен
concurrency limiter, заданный переменной окружения SEARCH_CONCURRENCY. При достижении лимита
на работу с данным endpoint-ом система возвращает HTTP статус 503 (service unavailable).

Для endpoint-а /api/isearch добавлен rate limiter, который регулируется переменной
окружения SEARCH_RATE. Данный limiter не возвращает 503, а задерживает соединения для регулировки
их скорости в пределах заданного переменной окружения RPS (requests per second).

Два критических endpoint-а защищены от доступа непривилегированными пользователями.
Доступ регулируется через 'POST /api/login' endpoint и middleware для проверки выданных логином
JWT токенов. "POST /api/login" принимает JSON в теле запроса вида
```
{
  "name": "admin",
  "password": "password"
}
```
и отдает токен ввиде строчки. "/api/login" проверяет пользователя и пароль, и если они не совпадают,
отдает HTTP Unauthorized. Если все ОК - выдает токен на время TOKEN_TTL (переменная среды,
2 минуты по умолчанию) с subject установленным в "superuser". При запросах на обновление базы
или ее удаление, добавлен middleware, который проверяет токен - 
HTTP Header вида "Authorization: Token выданный_токен_здесь". Если не удалось проверить токен -
HTTP Unauthorized.

## Тестирование

Код частично покрыт модульными и итеграционными тестами.

Тесты запускаются через make unit. Не покрыты тестами автосгенерированные файлы. Информация по покрытию тестами в
файле cover.html.